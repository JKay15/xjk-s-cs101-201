# http://cs101.openjudge.cn/2024sp_routine/21515/

这个题，我们基本框架应该还是图中的最短路，只是我们需要保存一额外的信息。

首先一个关键性质：
没有通路，自然-1；有通路，边的数量最少的通路，如果边数<=k，那么答案是0；如果边数最少的边也超过了k，那么答案就是路径中第k+1大的边的权值——这基本上本题最关键的性质了。

那么我们在使用优先队列的时候，怎么做？节点应该是用列表来存，存这么几个量，1. 当前路径长度。2. 如果当前路径长度小于等于k，那么就是当前路径中最小的边权，否则，就是路径中第k+1大的边权。3. 当前节点编号

于是我们优先按照路径长度排，先拓展短的路径，当路径长度大于k的时候，这个值就固定在k了，意思是这样的路径我们只按照当前路径中第k+1大的边权排序——于是这个量的更新也有讲究，当用来拓展的节点路径长度小于等于k的时候，就直接比较新的边权和当前最小值，谁小取谁；当当前路径长度大于k的时候，这是一个麻烦

我没有想到合适的处理手段，这条路似乎被堵死了。

我又想到这样的minmax问题，可能能用二分答案法做——不行

只能硬着头皮上我们的做法了，要保存第k+1大的，就不得不给每个节点加一个cnt字典，来进行动态更新了

废了，这里不能用cnt，因为边权不是差1的那种！
#未完待续 

我看到了答案里面说了这个题的做法是分层图最短路，但是我还没看出来这个图怎么分层了，也不知道分层图最短路要怎么做 
啊，原来就是这个啊，那我们见得多了，这个做法并没有什么好说的，我就是在用这个想法的过程中发现进行不下去的
![[../z_resources/CleanShot 2024-05-22 at 15.50.44@2x.png]]

而且有一个问题，vis数组没法优化，这里的排序标准是变化的，首先是路径长度，其次是第k+1大的值，我们会发现并不是路径长度更长就不应该拓展，也不一定是第k+1大的值更大就不应该拓展——路径长度好像没什么用（比如，两个都小于k的时候，如果不论如何都必须要大于k步，那么反而是目前的最小值更有价值，但也不一定有用），应该用第k+1大的值来，但好像也不行，总之就不能用vis数组优化。

这题实在是没有想法，我可能被现有的框架束缚住了。

看了标准答案中dijkstra的做法，他用更好的vis数字实现了dp，进而解决了我这里无法动态维护第k+1大的值的问题。

我们的问题就是让节点承担了过于多的作用了，而节点数量是很多的，一旦需要做的事情变多，要独立保存的信息就大大增加，内存是无法接受的。

这里的想法就是，额外增加一个dist数组，$dist[i][j]$来保存从1到i的使用j个免费边的情况下所需要的最小花费——于是初始值就都是inf，之后更新的时候，如果所需要的边小于等于k，那么就维持和前一个节点一样的dist值，否则一律j认为是k+1，并且值取最大值。
#未完待续 

![[../z_resources/CleanShot 2024-05-22 at 17.06.34@2x.png]]

还有更快的二分答案法
![[../z_resources/CleanShot 2024-05-22 at 17.06.53@2x.png]]

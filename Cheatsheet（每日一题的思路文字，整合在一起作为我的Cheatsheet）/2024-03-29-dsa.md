# http://cs101.openjudge.cn/2024sp_routine/01703/
这题是在并查集的基础上加了更多信息，来实现集合的“分离”操作，也就是，原本并查集只能接受“两个元素是同一集合”的信息，并且合并这两个元素所在集合，但是如果接受的是“两个元素不是同一个集合”的信息，那么只靠原本的映射数组，就做不到了
[[../daily_plan/2024-02-18|2024-02-18]]也做了这道题

这里很巧妙的处理是，新加一个数组，用%2这个操作来实现集合的“分离”，我们看一下具体的操作：
```python
set,a=[],[]
def find_set(i):
    global set,a
    if i==set[i]:return set[i]
    t=find_set(set[i])
    a[i]=(a[i]+a[set[i]])%2
    set[i]=t
    return t
def union(i,j):
    t1,t2=find_set(i),find_set(j)
    set[t1]=t2
    if a[j]==0:a[t1]=1-a[i]
    else:a[t1]=a[i]
    
for i in range(int(input())):
    n,m=list(map(int,input().split()))
    set,a,ans=[i for i in range(n+2)],[0 for i in range(n+2)],""
    for i in range(m):
        x,y,z=input().split()
        y,z=int(y),int(z)
        if x=='A':
            fx,fy=find_set(y),find_set(z)
            if fx!=fy:ans+="Not sure yet.\n"
            elif a[y]==a[z]:ans+="In the same gang.\n"
            else:ans+="In different gangs.\n"
        else:union(y,z)
    print(ans,end="")
```
基本操作还是一样，就是find和union，但是其中加入了新的操作，也就是对a数组的操作：
我们会发现a数组中只会有两种值：0和1，初始时都是0，在第一次union的时候有元素变成1，而unino虽然名字还是叫联合，但是其实unino的两个元素是属于不同集合的——我们当然希望一旦进行了union，这两个元素，以及这两个元素原本属于的集合中的所有元素都可以判断了
其中必不可少的操作就是“扁平化”——这个操作在一般的并查集中仅仅只是优化，并不会说是必不可少的，但是在我们这道题中，这是必不可少的，一旦缺少，就会无法判断是否不是同一集合/

以及，判断是否属于一个集合的方式，就是用a，a中的值相同，那就是一个集合，否则不是——但是这一切都取决于两个元素的父亲节点是一样的，否则就说明这俩元素还没确定

但是对于a的更新法则，我觉得还是有点太抽象了，目前依然无法在脑子里面立马想到，可能需要后续再手动画画看

发现一个性质：
（1）至多树的深度是两层，但是我不会证明

有一个直接的想法，就是每次给出两个不在一个集合的元素，就给这两个元素之间加上边（无向），于是我们每次要查询两个元素是否属于同一个帮派，就进行一次搜索，寻找这两个元素之间的最短通路（按道理应该只有一条通路，否则就成环了——不对，可以有环）——最暴力的搜索就是bfs了——如果能搜索到通路，那么就可以判断，否则无法判断

这个想法很直接，但是却有巨大缺点，就是太慢了

实际上，这道题涉及到对并查集这个数据结构的一般化理解：不应该仅仅停留在维护从属关系信息的理解上（尽管这个的确是并查集的最初目的）

## 并查集有什么特殊的？
特殊在father数组吗？不是吧，这个仅仅只是维护了边而已，和一般的树、图没有什么区别
特殊在查询父亲吗？这个也不算，因为一般的图也可以做到这一点
特殊在用根节点判断是否在同一集合吗？某种意义上算，这个有点像LCA，只是没有那么严格要求，所以干脆直接搜到根节点。

应该说特殊在这两点
（1）舍弃了树、图中具体的链接关系信息，仅仅关注于是否连通，只要连通就没有区别
（2）因为只关心连通性，所以为了提高搜索连通的效率，可以进行降低树高的优化——每次搜索根节点的过程，都将搜索路径上所有节点都重新连接到根节点上

## 并查集的一般化理解

唯一的本质：维护连通性的图（无向图，目前看来是，但是不确定是否可以使用有向图）

至于这个连通性在实际应用中含义，只需要这个含义满足连通性的基本性质就可以
#未完待续 我觉得得学好拓扑才能解释这个问题

于是我们这道题，连通性就被解构了，因为按照我们之前直接的想法，连通性不足够处理“不在同一集合”这个信息，还需要最短路径长度——但是好在我们只需要这个长度的奇偶性，或许我们能够不进行搜索，仅仅用一个额外标记来确定是否在一个集合内。

而连通性本身，也可以对应“有确定关心”这个含义，意思是，两个元素能够判断是否在一个集合内，在逻辑上，必须要他们所在集合内部任意两个元素有被提供信息（这道题中是“a和b不在一个集合”这样的信息）——意思是，我们一旦得到“a和b不在一个集合”这样的信息，就应该“并”a和b所在的图——于是如何并是一个问题——当然，按照并查集的传统，我们需要连接两个根节点——这个时候会涉及一个问题：就是原本两个图中保存的0、1信息无论如何只能说是相对信息，一旦连接新的图之后，很有可能出现相对信息不匹配的情况（因为我们图中的0、1仅仅只对连通部分成立，不连通的两部分的0、1可能含义是恰好相反的）

于是我们就需要考虑修正——如何修正呢？这应该就是find_set和union中额外的操作在做的事情了！
这个很复杂，动态调整十分厉害！
（1）的确，前面的性质说的不准确，只有我们关心的部分（D或者A的元素与根节点路径上所有的节点），树至多只有两层——因为树变大只有union的时候才行，而union调用了find_set，这会导致i、j与根节点必然是直接连接的状态，进一步连接根节点，如果前者的根节点和i不一样，就必然会形成两层的树（至于说这个根节点上是否挂了两层的路径，这个有可能的，因此完整的树是有可能大于两层的）
（2）这一定是一颗树，不会有环——因为并查集的连接方式，永远只连接根节点，因此不可能出现环（暂时不证明）
#未完待续 
（3）于是，每一颗树的根节点和子节点就是我们最基本的子结构
#未完待续 

> [!proposition] 并查集的局限
> 各节点关系是静态的，但最初未知，在不断给出信息的过程中，只能给出两个节点“在一个集合中”或者“无法判断”的判断，而不能直接给出“不在一个集合”的判断

当然意思是，如果最初关系是已知的，后需要修改，那么我们完全可以给出“不在一个集合”的判断

实际上有更直接的做法，就是开两倍的数组，每个人i，实际上对应了图中的两个节点i和i+n，于是这种并查集，可能叫做关系并查集，我们实现了这样的性质：
> [!proposition] 关系并查集的性质
> （1）如果两个人$i,j$，对应节点$i,j$处于一个集合，那么$i+n,j+n$也一定在一个集合，也意味着这两个人是同类
> （2）如果两个人$i,j$，对应节点$i,j+n$处于一个集合，那么$i+n,j$也一定在一个集合，也意味着这两个人是不同类
> （3）如果两个人$i,j$，对应节点$i,j$与$i,j+n$都无法判断，那么$i+n,j$也无法判断，意味着这两个人是否同类目前信息不足，不能判断

这个问题我因为两个原因无法继续研究
（1）我不知道为什么会想到使用一人对应两节点的方式来建立并查集
（2）我也不知道怎么证明这个并查集为什么拥有我们上面的性质，并且为什么能想到上面的性质
#未完待续 



# http://cs101.openjudge.cn/2024sp_routine/24686/

## 最初看错题的处理

这道题，我最初看错题了，认为是给除了根节点以外的所有子节点加上一个值，查询也只是查询某个节点的值是多少——于是处理就是把这个值存在根节点上；查询的时候就向上找父亲，把所有父亲的值和在一起就行了

后来发现好像是要求子树（但是还是搞错了，认为是除了根节点以外的子节点）的和，于是给从父亲那里得到的所有值的和乘上了一个子节点个数

后来又发现不行，于是把自身也加上了。

但是WA

## 想到要向上向下传播后的处理

原因是可能子树里面还有修改，我们只是求到了子树所有节点公共要加的值，这个查询很快（logk）——于是不得不遍历每一个子节点，把子节点的值算出来加上（这个就可能很慢了o(n)),

于是会有一个num和down，num负责向上传播给父亲节点，down负责更新所有儿子节点——但是一开始我们忘记了每个节点存的都是包括自己在内的子树的和，down里面直接给每个节点单独加上自己需要增加的值，而忘记了要包括儿子，所以WA了——改正了这一点之后就TLE了！

## 联系到了线段树想到了懒标记后的处理

于是想到这玩意和线段树非常像，只是线段树保存的是线性结构的值，这里没有，就是每个节点保存了所有子节点的和（按照我的处理的话）

于是我想到线段树里面有一个叫做懒标记的东西，要加先记着，当需要查询的时候再下传
但是有一个问题，因为我的每一个节点存的都是子节点的值的和，至于说子节点应该是多少，是没有记录的，需要额外的空间来记录。

那就再开一个数组来记录懒标记tag！每次更新，做两件事，第一，向上传播父节点，也就是之前的num，第二，给懒标记数组tag加上$a[2]$也就是每个子节点需要增加的值；每次查询，自己tree上的值肯定是要的，然后还要向上要所有父亲节点的懒标记的值，先递归到1，再把懒标记的值依次传下去（传的过程中有两种选择，一种是不更新tree的值，仅仅告诉我们需要的节点这棵子树每个节点需要加多少值；还有一种选择是更新tree的值，这样就不用重复计算了，效率更高）

但这个时候发现了一个问题，每个节点的懒标记按道理是对左右两个子树起作用的，但是如果更新tree的值，意味着tag以后不能再用了，变成0，对另一边的子树就有影响，于是我们为了提高这个效率，需要分别为左右子树存懒标记——这个反而是得不偿失了，于是放弃。


# http://cs101.openjudge.cn/2024sp_routine/04082/

这题的最大难点在于建树，至于说镜面反射，反而是简单的，只需要递归处理就好了

由于给出的树的信息是这样的：
```
a0 b0 $1 c0 d0 $1 e1 f1 $1
```
其中0是说明不是叶子结点，1说明是叶子结点，并且是前序遍历的序列。

那么首先把这些存在一个列表里面，之后第一项就是目前的根节点，之后会有左右子树，也就是说第二个必然是左子树的根节点——那么就需要判断是否是叶子结点，如果是，那么第三个之后就都是右子树了，否则递归下去，返回值必须是剩下的没处理的序列，这样就好了。

这倒是把二叉树建立出来了，但是问题是这道题镜面翻着不是对二叉树操作，而是对原本的树操作，可是题目压根没说怎么从原本的树得到的这颗二叉树，很诡异？

于是还需要建立多叉树，发现一个性质，就是多叉树的儿子是我的左儿子的所有右儿子（边），于是就建好了，

之后bfs就好

但是看到一个同学非常短的代码就过了，应该是有好性质我没发现，留给以后的我了！
![[../z_resources/CleanShot 2024-04-05 at 17.12.21@2x.png]]
#未完待续 


# http://cs101.openjudge.cn/2024sp_routine/01961/

显然是KMP的题目，但是我没有看出来KMP在哪

这里要求的是一个字符串的最短的循环节，也就是找到一个A，使得$S=A^{n}$，这个和字符串乘方是一个道理，那道题我没想到怎么用KMP

首先既然是循环节，那么必然满足前后缀相等的性质，也就是说：

$$
S[:l]=S[-l:]
$$
这个我们用KMP中处理next数组的方式是可以做的，但是知道这个信息并不足以让我们做出这道题——我们还要继续验证$S[:l]=S[-2l:-l]$，以此类推，因此，某个前缀能够成为答案的要求：
（1）长度l小于$next[-1]$，也就是小于整个S的前后缀匹配的最大长度
（2）长度l能够被S的长度整除
（3）如果$\frac{L_{S}}{l}=k$，那么要求$\forall i\in\{ 2,\dots,k-1 \},S[:l]=S[-i*l:-(i-1)*l]$
所以我们要做的就是从$1到next[-1]$遍历，把能行的都收集起来就好了

我去，看错题了！我们这个做法应该是用来做字符串乘方的，这题不是问的这个。

问的是这个S的所有前缀中可以被子串循环得到的长度和循环次数

这个其实也不冲突，我们做法还是一样的，就只是我们要对每个前缀都这么处理而已

还是有一个致命的错误，就是说next数组记录的确实是最长能够匹配的前后缀，但是并不意味着这个位置更短的前后缀就一定可以匹配，我们的算法默认了这件事，显然是不对的。

所以我们还要加上一个条件就是：
（4）要求对于最长前缀中的$next[f[i]]$要大于l

发现这一套压根行不通
```python
t=int(input())
ans,num='',1
while t:
    ans+="Test case #"+str(num)+'\n'
    num+=1
    s=input()
    f=[0]*(t+1)
    f[0],f[1]=-1,0
    for i in range(2,t+1):
        cur=f[i-1]
        while cur>=0 and s[i-1]!=s[cur]:cur=f[cur]
        f[i]=cur+1
    cur=''
    for i in range(2,t+1):
        for l in range(1,f[i]+1):
            if i%l==0:
                ok=1
                for j in range(i//l-1):
					now=i-j*l
					while now>0 and f[now]>l:now=f[now]
					if f[now]<l:
						ok=0
						break
                if ok:
                    cur+=str(i)+' '+str(i//l)+'\n'
                    break
    ans+=cur+'\n'
    t=int(input())
print(ans)
```
![[../z_resources/CleanShot 2024-05-24 at 11.17.58@2x.png]]
我这里的想法就是，我枚举循环节的长度l：
（1）l必须能够整除前缀总长度
（2）l必须要小于能够匹配的最大前后缀长度
（3）从$j\in\{ 1,\dots,k-1 \}$,$S[:l]==S[i-j*l: i-(j-1)*l]$，但是我们不能用切片，太慢了，于是转而判断在$j\in\{ 0,1,\dots,k-2 \}$上，$f[i-j*l]与l$的大小关系，如果前者更小，那么显然是不能匹配的，如果两者相等，那么就肯定可以，但是如果前者更大，我们是不能直接说两个可以匹配的，比如aabaab，l=2的时候其实不能匹配，虽然最大前后缀匹配长度是3——于是我们要去到$now=f[i-j*l]$上，看$f[now]$和l的关系，如果还大，那继续now赋值，直到f值等于或者小于l，我们才能判断能否匹配。


但是我们这个想法超时了，很烦。

我们其实对这个复杂度没什么概念，所以还是这么写了，看了正确答案之后，发现是dp而不能遍历l，所以我们首先看一下我们现在的复杂度为什么导致了超时：

首先就是必须要遍历的，每一个前缀长度，这个是n-1次，
对于每一个前缀长度，需要遍历每一个可能匹配的长度l，这个是$f[i]$次
对于每一个能整除的l，我们还要遍历每一个周期位置，这个是$\frac{i}{l}$次
对于每一个周期位置，我们还需要跳跃最多$i-l$次

所以最后的上界大概能到$n*n*n*n$这么多，显然会超时，我们嵌套了太多层，甚至于只看前两个循环，$O(n^{2})$也会超时，因为n到了1000000

所以我们得考虑更好的做法，基本上就是$O(n)$级别的了

于是我们不得不考虑不同长度前缀的循环节之间的关系，我们之前并没有去考虑这方面的问题。

首先，如果我的最长匹配的长度$f[i]$,相比于这个i来说，如果$f[i]*2\geq i$，也就是说这个匹配的长度前后会重叠：
.......
   .......
类似这种感觉，最好就是$f[i]*2==i$，于是只要我们求出来了$f[i]$位置的最小循环节，那么i位置的最小循环节一定也是一样的——首先我们说明$f[i]$的最小循环节是i的循环节，这显然，因为i就是两个$f[i]$拼起来的，所以就因为可加性就结束了；我们再说明这个也是i的最小循环节，如果还存在更小的循环节，我们要证明这不可能：

首先我们记$f[i]$的循环节A，满足$A^{n}=f[i]$，那么$A^{2n}=i$，如果存在一个更小的循环节B，使得$B^{m}=i$，$m>2n$，那么我们可以知道A的长度是$\frac{i}{2n}$，B的长度是$\frac{i}{m}$，那么显然B不是$f[i]$的循环节，否则产生矛盾。

并且我们可以说明，$\frac{i}{m}=\frac{2f[i]}{m}$一定不能整除$f[i]$，否则我们又可以用可加性说明矛盾，因为这样的话B肯定也不是A的循环节——这个要怎么说明呢？

很简单$i=B+B+{\dots}+B$，一共有$m$个B，因为$\frac{i}{m}$可以整除$f[i]$，所以显然m是偶数，那么我们取前$\frac{m}{2}$个B，就$f[i]=\frac{i}{2}=B+\dots +B$，这与$A$是$f[i]$的最小循环节矛盾。

于是我们有$\frac{m}{2}$不是整数，所以m必然是奇数，于是就有$i=\frac{m-1}{2}*B+B+\frac{m-1}{2}*B$
我们就会发现，产生矛盾了，因为我们已经说了$f[i]=\frac{i}{2}$，但是现在看来，i并不能被均分为相同的两部分，除非B也可以分为两个相同的部分——这又与B是最小循环节矛盾了。

于是我们就证明完毕了，$i=2f[i]$的时候，$f[i]$的最小循环节就是i的最小循环节。

那么其他情况呢？

首先如果整除是偶数——如果不是2，那说明过程中的部分肯定和最长匹配串不一样，我希望证明这个情况下就是做不到。

这个时候我突然想到了一个很重要的性质，之前一直忽略了。

那就是如果某个字符串S有最小循环节A，那么这个循环节的循环次数n是很关键的！
（1）如果n为偶数，那么$S=A^{\frac{n}{2}}+A^{\frac{n}{2}}$，于是S的next值至少是$\frac{n}{2}*len(A)$——但是反过来不一定（这个可以再说）
（2）如果n为奇数，那么$S=A^{\frac{n-1}{2}}+A+A^{\frac{n-1}{2}}$，于是S的next值至少是$\frac{n+1}{2}*len(A)$

等一下，好像可以这么考虑
（1.1)如果n是偶数，那么$S=A+A^{\frac{n-2}{2}}+A^{\frac{n-2}{2}}+A$，此时next值是$(n-1)*A$
（1.2)如果n是奇数，那么$S=A+A^{n-2}+A$，此时next值是$(n-1)*A$

边界情况是n=2，除此之外，似乎next值都必然比S的长度的一半要大，因此如果$f[i]*2<i$，那么就没有循环节！

因此如果$f[i]*2==i$，我们就可以断言，此时i处的最小循环节就是$f[i]$出的最小循环节，循环次数是$f[i]$的两倍，这个是前面证明了的。

如果$f[i]*2>i$，是否也有类似的结论？

　<font color='red'> 错误 </font>
　
显然如果$f[i]$有最小循环节B，$f[i]=B^{m}$，那么我们可以说明$i=B^{m+1}$，如果能够分得更细，也就是$B=C+D,i=B^{m}+D$，这意味着$B^{m}=C+B^{m-1}+D$，也就是$C+(D+B^{m-2}+C)+D=C+B^{m-1}+D$，最后会推导出$D+C=B$如果m是偶数，$D+B+C=B+B\implies D+C=B$，还是矛盾——于是我们说明了如果$f[i]$有最小循环节B，i的最小循环节也一定是B，并且循环次数比$f[i]$多1

上面证明错误了，这一步错了$B^{m}=C+B^{m-1}+D$，应该是$B^{m}=B[-C:]+B^{m-1}+D$，也就是$C+D+B^{m-2}+C+D=B[-C:]+B^{m-1}+D$，于是必然有$C=B[-C:]$，$D+B^{m-2}+C=B^{m-1}=B[:D]+B[-C:]+B^{m-3}+B[:D]+B[-C:]=B[:D]+C+B^{m-3}+B[:D]+C$
于是又必然有$D=B[:D]$
于是如果m为奇数，$D+B+C=D+C+D+C$
如果m为偶数，$D+B^{2}+C=D+C+B+D+C\implies B+B=C+D+C+D$
好像都没什么错误，前提是$C+D=D+C$
于是如果$f[i]=B+B,i=B+B+D=C+D+C+D+D$，此时是没有循环节的（这里不严谨），于是我们大胆猜测只要多出的D长度不能被$f[i]$所整除，那么就没有循环节。



如果$f[i]$没有最小循环节，也就是说不存在B，使得$f[i]=B^{m},m>1$，此时$i=f[i]+D$，如果i存在循环节A，则A的长度一定不被$f[i]$整除——不行，这个角度不好，我们还是从前面的n的分类讨论来看，一旦i有最小循环节A，$i=A^{n}$，那么必然有$f[i]=A^{n-1}$，想法依然是，如果可以更细分，$A=X+Y$,并且$f[i]=A^{n-1}+X$

那么有我断言最后依然会有$X+Y=Y+X$，又回到了原点。
#未完待续 


# http://cs101.openjudge.cn/2024sp_routine/04128/

这个题提醒我们写一般bfs还是要用deque，否则一般列表没有popleft
# http://cs101.openjudge.cn/2024sp_routine/28334/

首先猜测一个性质——一定需要保留一个入度为0的点

如果所有的点的入度都不为0，那么我总可以在这个点入度的来源点中选一个——运气好的话，会形成一条链，但是我们可以证明，在某次来源点的时候一定会出现找到这条链上已经出现的点，于是就出现了环——这是因为如果一直不出现的话，所有的点就练成了一条链，意味着结尾的点入度为0，这与假设矛盾。 ^3e496d

那么只有一个入度为0的点，是否一定保证没有环——并不是，完全可以构造一个环+孤立点

那么是否可以保留一个以上入度为0的点，依然是边最多的呢？我们可以证明，这显然不对，比如现在一共n个点，并且这些点满足（1）1、2号点是入度为0的（2）这n个点没有形成环（3）这n个点的边数是n个节点的DAG中最多的

显然，我们可以新加入一条边，就是从1指向2（反过来也行），这样依然可以保证不成环，如果这一条边能形成环，这条边一定在环中出现了，这也就意味着，有一条边指向1，但是这与1的入度为0的假设矛盾。

所以我们说明了，最有情况一定是只有一个点的入度为0——那么它就只有出度，并且这些出边并不会使得其他点中出现环——意味着这个点应该和其余所有点都连边，也就是n-1条边——所以我们把这个点从所有点中拿出去，那么我们还剩下n-1个点——我们是否也需要这n-1个点中得到DAG的最多边数——这是显然的，我就不证明了——于是问题变成了子问题——于是就有递推了。

所以答案就是，一个n个点的有向图，能形成的DAG中边数最多的值是
$$
\sum_{i=1}^{n-1}i=\frac{n(n-1)}{2}
$$
所以我们只要统计原本有多少条边（注意去重），记为x，答案就是$\frac{n(n-1)}{2}-x$

# http://cs101.openjudge.cn/2024sp_routine/01094/

依然是拓扑排序的问题，就是说给了一些大小关系，我们关心的是用所有的大小关系中的前多少条能最早实现排序完成或者出现矛盾

排序完成的标准很明显，就是仅剩下一个入度为0的点，并且没有成环——这还不够，一定要能够找到一条长度为n的链，并且没有成环才行。

产生矛盾的标准很明显，但是不好写代码判断，那就是成环了——但是这个我没有想到如何在短时间内动态进行判断。

于是这道题的最暴力直观的做法就是每加入一条边，我们就判断一下是否成环，并且判断一下是否有一条长度为n的链，这样就可以了

但是关键就在于这两个判断如何进行才是最高效的，如果实在效率不高，那么要怎么转化出合适的等价条件来进行判断？

首先拓扑排序肯定是首选的——并且我猜想了一个可能的性质，那就是如果拓扑排序的过程中，每次都只有一个点入度为0，并且最后没有成环的话，那么就说明排序完成，并且我们在拓扑排序过程中得到的出集合的节点序列就是排序好的序列。

所以就做完了，只需要一次拓扑排序就可以判断加入一条边之后的两个判断了，接下来我们要看一下拓扑排序本身的复杂度。

[[拓扑排序]]
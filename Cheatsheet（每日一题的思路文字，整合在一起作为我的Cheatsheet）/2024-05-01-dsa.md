# http://cs101.openjudge.cn/2024sp_routine/04130/

这题的各种条件给的很多，以至于我对于节点的设置、vis数组的优化还有路径信息的保存三个部分有了犹豫

## 节点的设置

状态空间——位置，钥匙情况两个——打蛇的情况呢？这个似乎不影响能不能完成任务，所以不放在状态空间中

于是蛇这个就单纯是导致了边权的不一致——两种处理手段，一个是为了这个蛇增加一个维度，使得这个节点变成俩；另一个就是走dijkstra，优先队列——这时候更新vis的时机也就严格要求是出队列的时候了——错误的，我们还是要区分，因为同一条路径上也不知道是否经过了这条蛇，所以还是要判断
## vis数组的优化

因为我们的状态空间中不含蛇，所以蛇节点其实就和普通节点没有区别，于是我们就正常vis优化就好了——vis数组需要区分位置（二维）+钥匙情况（vis数组的值，从0-N，代表收集到了第几个钥匙）——这里还有几个小细节

首先是出队的时候更新vis，有几把钥匙就更新为几，初始状态是-1——这个是错误的，会导致MLE——这也是这题我没搞清楚的点

这里我搞清楚了——本质上是bfs因为相比于dijkstra有更强的条件，于是可以进行更激进的vis数组优化——也就是入队的时候就更新vis——这个条件就是边权只与终点有关，与起点无关——于是我们可以证明这样优化vis是因为对应节点一定会在入队后成为队首（之一）
[[dijkstra]]

另外就是什么情况下会因为vis数组而忽略该路径——不只是和自己状态一样的vis不应该去，如果vis数组的值大于等于自己的钥匙数，也不应该去，因为不可能更短（证明还是一样，如果更少钥匙的能到终点，那么之前vis更新时更多钥匙的情况也可以按照更少钥匙后续路径原封不动地走——因为钥匙拿的顺序是一定的，所以更多钥匙就是严格好于更少钥匙）
## 路径信息的保存

这里我们就需要知道目前的状态就好了，也就是这条路径的最后节点的位置，目前的钥匙情况就好了

# http://cs101.openjudge.cn/2024sp_routine/01577/

这个就是单纯从根节点开始建树就得了，建树的方式就是按照二叉搜索来建——我傻了！
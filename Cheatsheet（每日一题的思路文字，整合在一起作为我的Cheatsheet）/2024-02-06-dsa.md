---
tags:
  - 未完待续
---

## http://dsa.openjudge.cn/sort/0808/

虽然知道了这道题是归并模版题，但是我并没有看出来为什么

题目的大概意思是只能够通过交换相邻元素的方式来得到一个降序序列（题目好像没看出来求最少交换次数的意思，题目的原话是Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.“”）

总之不管怎么样，就是求最小的交换次数，这个为什么能够转化为归并排序，我没啥头绪。

首先很明显，这是一个排序问题，我第一想法是用冒泡排序模拟一遍——但是因为要求最小的交换次数，所以显然存在nlogn的算法能够达到更小的交换次数——但是我并不知道如果说明归并就是我们需要的，因为归并排序的过程似乎不涉及相邻元素的交换（我也知道实际上这两种过程是可以转化的，也就是说归并是可以转化为相邻元素的交换的），我认为要考虑这个问题，需要思考归并的基本组成部分
1. 归并是首先拆分，将一个数列二分为多个片段，直到某个片段的长度达到1，也就是切分到最细——这个过程是不会发生交换的，因为这只是分治的预处理——为什么排序问题可以通过分治的预处理来加速？——首先如果能用分治，那么毫无疑问，肯定能加速——这是因为分治可以减少重复操作（可以说在排序问题中可以最大程度地减少重复操作），首先，最简单的排序是冒泡这一类，他们的重复操作在于，为了确定最大元素进行的比较，完全没有对后续确定次大元素起到作用，但是按照这个思路走，显然也没有什么优化空间——这个时候可以思考，为什么非要首先就确定最大元素？这显然没有必要，我们只要在排序结束的时候给出来顺序就好，至于说过程中是否能知道最大元素，这并不重要，我们完全可以接受甚至到排序结束才知道最大元素。那这就好说了，我们的比较就能被充分的利用——我们每次比较产生的相对顺序都要被反映在位置关系上，那么就不会浪费每一次比较——但是如果反应到位置关系，以及怎么比较，这个是需要设计的——我目前对分治的理解也就到这里了，通过二分的方式，优化了排序的比较和位置关系调整方式。——最后，为什么能够用分治，这个问题的解答反而是无聊的，只需要证明两个相邻的分治部分合并的时候能在线性时间内完成就好了
$$
let A=\set{a_1,a_2,...,a_n} \text{ and }B=\set{b_1,b_2,...,b_m} \text{ be two adjancent parts of the binary method result,}
$$
$$
\text{then we should prove than we can get C = }\set{c_1,c_2,...,c_{m+n}}\text{ ordered in O(n+m)} 
$$
$$
\text{we can define the operation to be a comparison between the first element of current A, B and put}
$$
$$
\text{the larger one into C with it be removed in its original set.}
$$
$$
\text{this operation is obviously a O(1) action, what we should do is to prove we can get C done in m+n times of operations.}
$$
$$
\text{By contradiction, if we can't get it done in m+n times of operations. let's say k times, where k>m+n.}
$$
$$
\text{It means we have remove more than m+n elements in A, B, which forms a contradiction.}
$$
$$
\text{Finally, we have prove it.}
$$
	然后，分治保证了这样的操作不超过logn次（我就不证明了），于是就是nlogn（当然这和为什么能用分治无关）
2. 接下来就是归并中并的部分，这部分和交换有关。最简单的合并，就是两部分的数量都只有1，那么这个并如果有必要，就算是一次交换（和冒泡排序中的交换没有区别），接下来是两部分都是2（或者一个1一个2，由于归并的划分，使得两部分之间不可能差别超过1），内部已经交换好了，又因为这两部分是相邻的，所以我们知道，将一个元素移动到这一整段的所需位置需要的交换次数，那么归并中的这个两个部分比较放置的过程也就是不断地交换了（虽然说我们实际处理不会这么去做，因为写这么多次交换很烦，我们会另取一个容器一个一个按顺序放进去，然后再一个一个地覆盖掉原本的元素，这样做似乎会更快一点，因为我们使用了额外的空间，但是如果只能交换的话，就没办法）。即使如此，我觉得这个交换次数也是少于冒泡的，怎么证明？
	好像没办法证明少于冒泡，我完全可以构造出一个最差的情况，就是后一半都是小于前一半的，这样的情况下，复杂度就是O($n^2$)的，和冒泡没区别。
3. 所以研究到这里，就得看题解了
嗯，冒泡超时了，说明大概交换次数上，这俩是一样的，但是冒泡要算出这个次数，太慢了，归并可以加速

接下来可以证明一下为什么这两种排序如果只能交换相邻元素的情况下交换次数是一样的，延伸开是不是所有排序算法在这样的限制下都是如此。
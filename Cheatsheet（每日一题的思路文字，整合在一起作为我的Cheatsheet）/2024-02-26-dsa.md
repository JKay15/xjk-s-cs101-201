#未完待续
## http://cs101.openjudge.cn/dsapre/06648/


就是一个矩阵，我们要在每一行取一个数，要给出这样的序列和的前n大的值

最多m=100行，最多1000列，n和列数相同

第一想法就是没得做，如果要用二叉树往下递归，这个复杂度是完全受不住的，基本上必须要找出一个

答案的做法是一行一行做预处理，处理的手段是优先队列，处理完毕就好了
https://blog.csdn.net/qq_56721787/article/details/121662321

```c++
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
using PII=pair<int,int>;
const int N=2e3+10;
 
int a[N],b[N],temp[N];
//a表示前几个序列的前n个最小序列和(最后表示m个序列的最小序列和)
//b表示未匹配的数组，temp表示中途过渡的数组
int m,n;
void work(){
    priority_queue<PII,vector<PII>,greater<PII>>heap;//小根堆pair存储序列和和下标
    for(int j=0;j<n;++j)
        heap.push({a[0]+b[j],0});//初始一次性加入a[0]+b[j](0~n-1)
    for(int j=0;j<n;++j){
        auto t=heap.top();//取出堆顶
        heap.pop();
        int sum=t.first,i=t.second;//sum存储和，i存储在a数组的位置
        temp[j]=sum;//过渡存储和
        heap.push({sum-a[i]+a[i+1],i+1});//由于b[0]~b[n-1]已经全部加入，只需加入a[i+1],b[j]
    }
    for(int i=0;i<n;++i)
        a[i]=temp[i];//将结果过渡到a数组中
}
 
int main()
{
    int T;
    cin>>T;
    while(T--){
        cin>>m>>n;
        for(int i=0;i<n;++i) cin>>a[i];//a数组作为起始序列
        sort(a,a+n);//排序
        for(int i=0;i<m-1;++i){
            for(int j=0;j<n;++j)
                cin>>b[j];
            work();//每次将a，b两个序列匹配
        }
        for(int i=0;i<n;++i) cout<<a[i]<<' ';//最后a数组表示最终结果
        cout<<endl;
    }
    return 0;
}
```

这个算法，我们可以先考虑两个序列a和b，我们希望找出其中各取一个元素的和的最小的n个

这个算法，会首先把$a[0]+b[i],\forall 1\leq i\leq n$加入小根堆，之后进行n次操作，每次操作取出堆顶元素，假设是$a[i]+b[j]$，那么我们将$a[i+1]+b[j]$压回小根堆，并且记录$temp[第k次操作的k]=a[i]+b[j]$，最后$temp[i]$就是第i+1小的元素和

这是为什么呢？
实际上我们是有一个贪心本能的
考虑我们如果只是要找这些和中最小的那一个，那么显然是找出两个序列中最小的元素之后加起来就好了
那么第二小的呢？显然是其中的最小+另外一个的次小，有两种可能，需要比较
之后一次类推，会有一个二叉树产生，这也是为什么我说会超时，这显然是指数级别的

那么这个算法在做的事情，就是先找到$a[0]+b[i]$中最小的，因为$a[0]是a中最小的$，显然这个和的最小值是由b中的最小值产生的，之后把这个值记录为$temp[0]$是毫无问题的，这个最小值在被记录之后也就不需要继续储存在小根堆中了，现在这个小根堆中已经有了a的最小+b的次小，我们之后要和a的次小+b的最小比较，而$temp[0]$恰好有b的最小，我们把$a[1]+temp[0]-a[0]$放进小根堆就好了

之后，很关键的剪枝，一旦我们确定了，比如，a的最小+b的次小是第二小的和，那么我们在计算第三小的和的时候是否有必要考虑a的次小+b的最小以及它的替换

（替换的定义：对于一个二元和$a_{i}+b_{j}$，我们称这个和的替换是指，将其中的$a_{i}$换成为其下位（也就是说，如果$a_{i}是a中第k小的值$，它的下位就是a中第k+1小的值）之后，与$b_{j}$相加，以及，将其中的$b_{j}$换成其下位之后，与$a_{i}$相加）——我们显然可以看出，替换会是所有比$a_{i}+b_{j}$大的和中最小的两个？？？——想了想好像不是很对的样子——但是有一个特点，如果存在其他的和比$a_{i}+b_{j}$大，且比替换都要小，不妨设这个和是$a_{p}+b_{q}$，那么显然，$a_{p}比a_{i}小与b_{q}比b_{j}小$这两件事必然要发生且仅发生一件——前者已经包含在小根堆中了——好像也不一定？——这个考虑不对，因为没有考虑$a_{i}+b_{j}$之前处理产生的信息，因此无法进行下去了





